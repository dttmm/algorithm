#include <fstream>
#include <iostream>

/*
* 설계 9분 구현 5분
* dp
* 어떻게 작은 문제로 쪼갤 수 있을까 고민함
* 만약 n번째 우리를 추가하는 경우
* 이미 n-1번째 우리가 완성이 되어 있다면
* n번째 우리에서 사자가 아예 없는 경우, 사자가 왼쪽에 있는 경우, 사자가 오른쪽에 있는 경우를 나누어
* 각각의 경우를 만족하는 경우를 따져봄
* 
* 1. n번째에 사자가 아예 없는 우리를 추가하게 될 경우
* n-1번째 마지막 우리에는 사자가 있든 없든 추가를 할 수 있음
* 
* 2. n번째에 왼쪽에 사자가 있는 우리를 추가하게 될 경우
* n-1번째 마지막 우리에는 사자가 없거나 사자가 오른쪽에 있어야됨
* 
* 3. n번째에 오른쪽에 사자가 있는 우리를 추가하게 될 경우
* n-1번째 마지막 우리에는 사자가 없거나 사자가 왼쪽에 있어야됨
* 
* n번째 마지막 우리에 사자가 없, 왼, 오른쪽에 있는 경우 3가지로 나눠서
* 이차원 dp 생각함 d[N][3]
* 
* 초기값은 다음과 같이 시작하고
* d[1][0] = 1	<- 1번째 우리 마지막에 사자가 없는 경우
* d[1][1] = 1	<- 1번째 우리 왼쪽에 사자가 있는 경우
* d[1][2] = 1	<- 1번째 우리 오른쪽에 사자가 있는 경우
* 
* 두번째 우리를 추가하는 경우는 다음과 같이 됨
* d[2][0] = 3	<- 2번째 우리 마지막에 사자가 없는 경우 (d[1][0] + d[1][1] + d[1][2])
* d[2][1] = 2	<- 2번째 우리 왼쪽에 사자가 있는 경우 (d[1][0] + d[1][2])
* d[2][2] = 2	<- 2번째 우리 오른쪽에 사자가 있는 경우 (d[1][0] + d[1][1])
* 
* 여기서 주목할 점은 d[N][1]과 d[N][2]이라는 것임
* 즉, 사자가 왼쪽에 있는 경우와 오른쪽에 있는 경우의 경우의 수가 같으니
* 굳이 배열을 두 개 사용할 필요없이 하나의 배열만 사용해도 됨
* 
* 그럼 점화식을 다음과 같던 기존식에서
* d[i][0] = d[i-1][0] + d[i-1][1] + d[i-1][2]
* d[i][1] = d[i-1][0] + d[i-1][2]
* d[i][2] = d[i-1][0] + d[i-1][1]
* 
* 다음식으로 바꿀 수 있음
* d[i][0] = d[i-1][0] + d[i-1][1] + d[i-1][1]
* d[i][1] = d[i-1][0] + d[i-1][1]
* 
* 두 점화식에서 d[i-1][0] + d[i-1][1] 이 부분이 중복되므로
* 다음과 같이 사자가 한쪽에 있는 경우를 먼저 계산하여 중복을 줄일 수 있음
* d[i][1] = d[i-1][0] + d[i-1][1]
* d[i][0] = d[i][1] + d[i-1][1]
*/

using namespace std;

#define MAX_N 100000
#define MOD 9901

int N;
int d[MAX_N + 1][2];	// i번째 우리 마지막에 사자가 있는지 유무. j=0: 사자가 없는 경우, j=1: 사자가 있는 경우(왼쪽에 사자가 있거나 오른쪽에 사자가 있는 경우)

// dp 배열 채움
void solve() {
	d[1][0] = 1;
	d[1][1] = 1;

	for (int i = 2; i <= N; i++) {
		// 마지막에 사자가 있는 우리를 추가할 수 있는 경우
		// -> 앞 우리에 사자가 없거나(d[i - 1][0]) 앞 우리와 현재 우리에 서로 상반된 위치에 사자가 있는 경우
		d[i][1] = (d[i - 1][0] + d[i - 1][1]) % MOD;

		// 마지막에 사자가 없는 우리를 추가할 수 있는 경우
		// -> 어떤 경우든 상관 없음 (앞 우리에 사자가 없는 경우 + 앞 우리 왼쪽에 사자가 있는 경우 + 앞 우리 오른쪽에 사자가 있는 경우)
		// 앞 우리에 사자가 있는 경우 + 앞 우리 한쪽에 사자가 있는 경우는 이미 d[i][1]에 계산되어 있으므로 d[i][1]재사용하고 나머지 한쪽에 사자가 있는 경우 더해줌
		d[i][0] = (d[i][1] + d[i - 1][1]) % MOD;
	}
}

int main() {

	freopen("res/baekjoon/1309.txt", "r", stdin);

	// 입력
	cin >> N;

	// dp
	solve();

	// 정답: 현재 우리 마지막에 사자가 없는 경우 + 사자가 왼쪽에 있는 경우 + 사자가 오른쪽에 있는 경우
	// 사자가 왼쪽에 있는 경우와 오른쪽에 있는 경우는 경우의 수가 같으므로 한쪽에 사자가 있는 경우(d[N][1])를 두배 해줌
	int ans = (d[N][0] + 2 * d[N][1]) % MOD;

	cout << ans;
}